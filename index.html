<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8" />
  <title>Vineyard Map (Boundary + Grid + GPS Walking)</title>
  <link rel="manifest" href="/manifest.webmanifest">
  <meta name="theme-color" content="#ffffff"> 
  <link rel="apple-touch-icon" href="/icons/icon-192.png">

  <style>
    body { margin: 0; font-family: Arial, sans-serif; }
    #map { height: 100vh; width: 100%; }

    .controls {
      position: absolute;
      top: 10px;
      left: 10px;
      background: white;
      padding: 10px;
      border-radius: 8px;
      box-shadow: 0 2px 8px rgba(0,0,0,0.25);
      z-index: 1;
      min-width: 330px;
      user-select: none;
    }
    .row { margin-top: 8px; }
    .row label { display: block; font-size: 12px; margin-bottom: 4px; color: #333; }
    .row input[type="range"] { width: 100%; }
    .btnRow { display: flex; gap: 6px; flex-wrap: wrap; }
    button { flex: 1; padding: 7px 8px; cursor: pointer; }
    .small { font-size: 12px; color: #555; margin-top: 4px; line-height: 1.25; }
    .mono { font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace; }
    .pill {
      display: inline-block;
      padding: 2px 6px;
      border-radius: 999px;
      background: #f2f2f2;
      font-size: 12px;
    }
  </style>

  <script
    src="https://maps.googleapis.com/maps/api/js?key=AIzaSyAmR2Rk1b0drx0zCWI6LMjdkRP2f_Lk-0E&callback=initMap"
    async defer>
  </script>
</head>

<body>
  <div class="controls">
    <strong>Layers</strong>
    <div class="btnRow row">
      <button onclick="toggleBoundary()">Boundary</button>
      <button onclick="toggleGrid()">Grid</button>
      <button onclick="fitToBoundary()">Fit boundary</button>
      <button onclick="fitToGrid()">Fit grid</button>
    </div>

    <div class="row">
      <label>Grid rotation: <span id="rotLabel" class="mono">0°</span></label>
      <input id="rotSlider" type="range" min="-180" max="180" step="1" value="0" />
      <div class="small">
        Rotation is about the boundary center. Use Snap-to-fit for auto alignment.
      </div>
    </div>

    <div class="btnRow row">
      <button onclick="snapToBoundaryBearing()">Snap bearing</button>
      <button onclick="addRotation(90)">+90°</button>
      <button onclick="addRotation(-90)">−90°</button>
      <button onclick="snapToFit()">Snap to fit</button>
    </div>

    <hr style="margin:10px 0; border:none; border-top:1px solid #eee;">

    <strong>GPS Walking</strong>
    <div class="btnRow row">
      <button onclick="startGPS()">Start GPS</button>
      <button onclick="stopGPS()">Stop GPS</button>
      <button onclick="toggleFollow()">Follow: <span id="followLabel" class="mono">ON</span></button>
    </div>

    <div class="row small">
      Boundary bearing: <span id="bearingLabel" class="mono">—</span><br>
      Pivot: <span id="pivotLabel" class="mono">—</span><br>
      GPS: <span id="gpsLabel" class="mono">OFF</span> &nbsp; Accuracy: <span id="accLabel" class="mono">—</span><br>
      You are in: <span id="zoneLabel" class="pill">—</span>
    </div>
  </div>

  <div id="map"></div>

  <script>
    // Files
    const KML_FILE = "BlkAZones_3_Boundary.kml";
    const JSON_FILE = "BlkAZones_3_Prescription.json";

    // Boundary
    let map;
    let boundaryPolygon = null;
    let boundaryVisible = true;
    let boundaryBounds = null;

    // Grid
    let gridVisible = true;
    let prescriptionData = null;

    // Rotation
    let rotationDeg = 0;
    let vineyardBearingDeg = null;

    // Pivot (boundary center)
    let pivotLatLng = null;

    // Clip grid to boundary (center-point clip)
    const CLIP_TO_BOUNDARY = true;

    // Rendered cell cache for GPS hit-testing
    // { id, level, dosage, center:{lat,lng}, ring:[{lat,lng}...] }
    let renderedCells = [];

    // Highlighted cell id
    let highlightedCellId = null;

    // GPS state
    let gpsWatchId = null;
    let gpsMarker = null;
    let gpsAccuracyCircle = null;
    let followMode = true;

    // meters → degrees (vineyard-scale approximation)
    const metersToLat = (m) => m / 111320;
    const metersToLng = (m, lat) => m / (111320 * Math.cos(lat * Math.PI / 180));
    const degToRad = (d) => d * Math.PI / 180;

    // ---------- Geometry helpers ----------
    function bearingDegrees(a, b) {
      const lat1 = degToRad(a.lat);
      const lat2 = degToRad(b.lat);
      const dLng = degToRad(b.lng - a.lng);
      const y = Math.sin(dLng) * Math.cos(lat2);
      const x = Math.cos(lat1) * Math.sin(lat2) - Math.sin(lat1) * Math.cos(lat2) * Math.cos(dLng);
      let brng = Math.atan2(y, x) * 180 / Math.PI;
      brng = (brng + 360) % 360;
      return brng;
    }

    function rotateEN(eastM, northM, thetaRad) {
      const cosT = Math.cos(thetaRad);
      const sinT = Math.sin(thetaRad);
      return {
        east:  eastM * cosT - northM * sinT,
        north: eastM * sinT + northM * cosT
      };
    }

    // Point-in-polygon (ray casting) in lat/lng space
    // polygon: array of {lat,lng}
    function pointInPolygon(pt, polygon) {
      const x = pt.lng, y = pt.lat;
      let inside = false;

      for (let i = 0, j = polygon.length - 1; i < polygon.length; j = i++) {
        const xi = polygon[i].lng, yi = polygon[i].lat;
        const xj = polygon[j].lng, yj = polygon[j].lat;

        const intersect =
          ((yi > y) !== (yj > y)) &&
          (x < (xj - xi) * (y - yi) / ((yj - yi) || 1e-12) + xi);

        if (intersect) inside = !inside;
      }
      return inside;
    }

    // ---------- UI ----------
    function setText(id, text) { document.getElementById(id).textContent = text; }

    function updateUI() {
      setText("rotLabel", `${rotationDeg}°`);
      setText("bearingLabel", (vineyardBearingDeg == null) ? "—" : `${vineyardBearingDeg.toFixed(1)}°`);
      setText("pivotLabel", (pivotLatLng == null) ? "—" : `${pivotLatLng.lat().toFixed(6)}, ${pivotLatLng.lng().toFixed(6)}`);
      setText("followLabel", followMode ? "ON" : "OFF");
    }

    function setZoneLabel(text) { document.getElementById("zoneLabel").textContent = text; }

    // ---------- Init ----------
    function initMap() {
      map = new google.maps.Map(document.getElementById("map"), {
        mapTypeId: "satellite",
        center: { lat: -33.798, lng: 115.078 },
        zoom: 17
      });

      setupGridStylingAndClicks();

      // slider
      const slider = document.getElementById("rotSlider");
      slider.addEventListener("input", () => {
        rotationDeg = parseInt(slider.value, 10);
        updateUI();
        rerenderGrid();
        // When grid changes, re-evaluate current location highlight if GPS active
        if (gpsMarker) highlightCellAt(gpsMarker.getPosition());
      });

      updateUI();
      setText("gpsLabel", "OFF");
      setText("accLabel", "—");
      setZoneLabel("—");

      loadBoundaryFromKml(KML_FILE)
        .then(() => fetch(JSON_FILE))
        .then(r => {
          if (!r.ok) throw new Error("Failed to load prescription JSON");
          return r.json();
        })
        .then(data => {
          prescriptionData = data;

          if (typeof data.rotation === "number" && data.rotation !== 0) {
            rotationDeg = Math.round(data.rotation);
            document.getElementById("rotSlider").value = rotationDeg;
          }
          updateUI();
          rerenderGrid();
        })
        .catch(err => {
          console.error(err);
          alert("Error loading boundary or prescription data. Check console.");
        });
    }

    // ---------- Boundary ----------
    async function loadBoundaryFromKml(kmlPath) {
      const res = await fetch(kmlPath);
      if (!res.ok) throw new Error("Failed to load KML: " + kmlPath);

      const text = await res.text();
      const xml = new DOMParser().parseFromString(text, "application/xml");

      let coordNode = xml.querySelector("Polygon coordinates")
        || xml.querySelector("LinearRing coordinates")
        || xml.querySelector("coordinates");

      if (!coordNode) throw new Error("No <coordinates> found in KML");

      const coordsText = coordNode.textContent.trim();
      const path = coordsText
        .split(/\s+/)
        .map(s => s.trim())
        .filter(Boolean)
        .map(pair => {
          const parts = pair.split(",").map(Number);
          return { lng: parts[0], lat: parts[1] };
        })
        .filter(p => Number.isFinite(p.lat) && Number.isFinite(p.lng));

      if (path.length < 3) throw new Error("Boundary coordinates too short");

      if (boundaryPolygon) boundaryPolygon.setMap(null);

      boundaryPolygon = new google.maps.Polygon({
        paths: path,
        strokeColor: "#00FFFF",
        strokeOpacity: 0.9,
        strokeWeight: 2,
        fillColor: "#00FFFF",
        fillOpacity: 0.08,
        map
      });

      boundaryBounds = new google.maps.LatLngBounds();
      path.forEach(p => boundaryBounds.extend(p));
      map.fitBounds(boundaryBounds);

      pivotLatLng = boundaryBounds.getCenter();

      vineyardBearingDeg = computeDominantBearing(path);

      // Save ring for clipping/hit-tests
      window.__boundaryRing = path;

      updateUI();
    }

    function computeDominantBearing(path) {
      let best = { dist2: -1, a: null, b: null };
      for (let i = 0; i < path.length - 1; i++) {
        const a = path[i], b = path[i + 1];
        const dLat = b.lat - a.lat;
        const dLng = b.lng - a.lng;
        const dist2 = dLat*dLat + dLng*dLng;
        if (dist2 > best.dist2) best = { dist2, a, b };
      }
      if (!best.a || !best.b) return 0;
      return bearingDegrees(best.a, best.b);
    }

    // ---------- Grid rendering ----------
    function clearGrid() {
      map.data.forEach(f => map.data.remove(f));
      renderedCells = [];
      highlightedCellId = null;
      setZoneLabel("—");
    }

    function rerenderGrid() {
      if (!prescriptionData || !pivotLatLng) return;
      clearGrid();
      renderPrescriptionGrid(prescriptionData, rotationDeg);
      map.data.setStyle(map.data.getStyle());
    }

    function renderPrescriptionGrid(data, rotDeg) {
      const { rows, columns, cellSize, originLat, originLng, weightData, dataTypeLevel } = data;

      const dosageMap = {};
      (dataTypeLevel || []).forEach(d => dosageMap[d.level] = d.dosage);

      const theta = degToRad(rotDeg);

      // Pivot EN meters relative to origin
      const pivotLat = pivotLatLng.lat();
      const pivotLng = pivotLatLng.lng();
      const pivotNorthM = (pivotLat - originLat) * 111320;
      const pivotEastM  = (pivotLng - originLng) * (111320 * Math.cos(pivotLat * Math.PI / 180));

      const boundaryRing = window.__boundaryRing || null;

      let idCounter = 0;

      for (let row = 0; row < rows; row++) {
        for (let col = 0; col < columns; col++) {
          const idx = row * columns + col;
          const level = weightData[idx];
          if (!level || level === 0) continue;

          // Orientation you solved: flip ONLY Y, keep X
          const drawRow = (rows - 1 - row);
          const drawCol = col;

          const eastM0  = drawCol * cellSize;
          const northM0 = drawRow * cellSize;

          // Rotated CENTER (for clip + GPS hit test)
          const centerLL = (() => {
            const e = eastM0 + cellSize/2;
            const n = northM0 + cellSize/2;

            const eRel = e - pivotEastM;
            const nRel = n - pivotNorthM;

            const rot = rotateEN(eRel, nRel, theta);
            const e2 = rot.east + pivotEastM;
            const n2 = rot.north + pivotNorthM;

            const lat = originLat + metersToLat(n2);
            const lng = originLng + metersToLng(e2, lat);
            return { lat, lng };
          })();

          // Clip by boundary
          if (CLIP_TO_BOUNDARY && boundaryRing) {
            if (!pointInPolygon(centerLL, boundaryRing)) continue;
          }

          // Rotated corners around pivot
          const cornersLL = [
            { e: eastM0,            n: northM0 },
            { e: eastM0 + cellSize, n: northM0 },
            { e: eastM0 + cellSize, n: northM0 + cellSize },
            { e: eastM0,            n: northM0 + cellSize },
            { e: eastM0,            n: northM0 },
          ].map(p => {
            const eRel = p.e - pivotEastM;
            const nRel = p.n - pivotNorthM;
            const rot = rotateEN(eRel, nRel, theta);
            return { east: rot.east + pivotEastM, north: rot.north + pivotNorthM };
          }).map(p => {
            const lat = originLat + metersToLat(p.north);
            const lng = originLng + metersToLng(p.east, lat);
            return { lat, lng };
          });

          const id = idCounter++;

          const feature = {
            type: "Feature",
            id,
            properties: {
              level,
              dosage: (dosageMap[level] ?? null),
              row,
              column: col
            },
            geometry: {
              type: "Polygon",
              coordinates: [cornersLL.map(p => [p.lng, p.lat])]
            }
          };

          map.data.addGeoJson(feature);

          // Cache for GPS hit-testing
          renderedCells.push({
            id,
            level,
            dosage: (dosageMap[level] ?? null),
            center: centerLL,
            ring: cornersLL // array of {lat,lng}
          });
        }
      }
    }

    function setupGridStylingAndClicks() {
      map.data.setStyle((f) => {
        const level = f.getProperty("level");
        const id = f.getId();

        // Base palette: level 1 red, 2 orange, 3 green
        let color = "#FF0000";
        if (level === 2) color = "#FFA500";
        if (level === 3) color = "#00FF00";

        const isHighlighted = (id === highlightedCellId);

        return {
          fillColor: color,
          fillOpacity: isHighlighted ? 0.75 : 0.55,
          strokeColor: isHighlighted ? "#00BFFF" : "#000000",
          strokeOpacity: isHighlighted ? 1.0 : 0.6,
          strokeWeight: isHighlighted ? 2.5 : 0.3,
          visible: gridVisible
        };
      });

      map.data.addListener("click", (e) => {
        const html = `
          <strong>Level:</strong> ${e.feature.getProperty("level")}<br>
          <strong>Dosage:</strong> ${e.feature.getProperty("dosage")}<br>
          <strong>Cell:</strong> R${e.feature.getProperty("row")} C${e.feature.getProperty("column")}
        `;
        new google.maps.InfoWindow({ content: html, position: e.latLng }).open(map);
      });
    }

    // ---------- GPS Walking mode ----------
    function startGPS() {
      if (!navigator.geolocation) {
        alert("Geolocation not supported by this browser.");
        return;
      }
      if (gpsWatchId != null) return; // already running

      setText("gpsLabel", "ON");

      gpsWatchId = navigator.geolocation.watchPosition(
        (pos) => {
          const lat = pos.coords.latitude;
          const lng = pos.coords.longitude;
          const acc = pos.coords.accuracy; // meters

          setText("accLabel", `${Math.round(acc)}m`);

          const latLng = new google.maps.LatLng(lat, lng);

          // Marker
          if (!gpsMarker) {
            gpsMarker = new google.maps.Marker({
              position: latLng,
              map,
              title: "You",
              optimized: true
            });
          } else {
            gpsMarker.setPosition(latLng);
          }

          // Accuracy circle
          if (!gpsAccuracyCircle) {
            gpsAccuracyCircle = new google.maps.Circle({
              map,
              center: latLng,
              radius: acc,
              strokeOpacity: 0.4,
              strokeWeight: 1,
              fillOpacity: 0.12
            });
          } else {
            gpsAccuracyCircle.setCenter(latLng);
            gpsAccuracyCircle.setRadius(acc);
          }

          if (followMode) {
            map.panTo(latLng);
          }

          // Highlight current cell
          highlightCellAt(latLng);
        },
        (err) => {
          console.error("GPS error:", err);
          setText("gpsLabel", "ERROR");
          alert("GPS error: " + err.message);
        },
        {
          enableHighAccuracy: true,
          maximumAge: 1000,
          timeout: 15000
        }
      );
    }

    function stopGPS() {
      if (gpsWatchId != null) {
        navigator.geolocation.clearWatch(gpsWatchId);
        gpsWatchId = null;
      }
      setText("gpsLabel", "OFF");
      setText("accLabel", "—");
      setZoneLabel("—");

      if (gpsMarker) { gpsMarker.setMap(null); gpsMarker = null; }
      if (gpsAccuracyCircle) { gpsAccuracyCircle.setMap(null); gpsAccuracyCircle = null; }

      highlightedCellId = null;
      map.data.setStyle(map.data.getStyle());
    }

    function toggleFollow() {
      followMode = !followMode;
      updateUI();
    }

    function highlightCellAt(latLng) {
      // If grid not rendered yet, do nothing
      if (!renderedCells || renderedCells.length === 0) return;

      const pt = { lat: latLng.lat(), lng: latLng.lng() };

      // Fast-ish approach:
      // 1) find nearest by center (cheap)
      // 2) confirm with point-in-polygon for that candidate and a few neighbors
      // Given small number of cells, brute force is fine too — but this is smoother.

      let best = null;
      let bestD2 = Infinity;

      for (const cell of renderedCells) {
        const dLat = cell.center.lat - pt.lat;
        const dLng = cell.center.lng - pt.lng;
        const d2 = dLat*dLat + dLng*dLng;
        if (d2 < bestD2) {
          bestD2 = d2;
          best = cell;
        }
      }

      // If nearest center isn't inside (possible near edges), brute force inside check
      let insideCell = null;
      if (best && pointInPolygon(pt, best.ring)) {
        insideCell = best;
      } else {
        for (const cell of renderedCells) {
          if (pointInPolygon(pt, cell.ring)) { insideCell = cell; break; }
        }
      }

      const newId = insideCell ? insideCell.id : null;

      if (newId !== highlightedCellId) {
        highlightedCellId = newId;
        map.data.setStyle(map.data.getStyle());

        if (insideCell) {
          setZoneLabel(`Level ${insideCell.level} • Dosage ${insideCell.dosage ?? "—"}`);
        } else {
          setZoneLabel("Outside grid");
        }
      }
    }

    // ---------- Controls ----------
    function toggleBoundary() {
      if (!boundaryPolygon) return;
      boundaryVisible = !boundaryVisible;
      boundaryPolygon.setMap(boundaryVisible ? map : null);
    }

    function toggleGrid() {
      gridVisible = !gridVisible;
      map.data.setStyle(map.data.getStyle());
    }

    function addRotation(deltaDeg) {
      rotationDeg = ((rotationDeg + deltaDeg + 180) % 360) - 180;
      document.getElementById("rotSlider").value = rotationDeg;
      updateUI();
      rerenderGrid();
      if (gpsMarker) highlightCellAt(gpsMarker.getPosition());
    }

    function snapToBoundaryBearing() {
      if (vineyardBearingDeg == null) { alert("Boundary bearing not available yet."); return; }
      rotationDeg = Math.round(vineyardBearingDeg);
      document.getElementById("rotSlider").value = rotationDeg;
      updateUI();
      rerenderGrid();
      if (gpsMarker) highlightCellAt(gpsMarker.getPosition());
    }

    async function snapToFit() {
      if (!prescriptionData || !pivotLatLng || !window.__boundaryRing) {
        alert("Need boundary + prescription loaded first.");
        return;
      }

      const base = (vineyardBearingDeg != null) ? vineyardBearingDeg : rotationDeg;

      const coarse = searchBestRotation(base, 20, 1.0);
      const fine = searchBestRotation(coarse.bestDeg, 2, 0.2);

      rotationDeg = Math.round(fine.bestDeg * 10) / 10;
      document.getElementById("rotSlider").value = rotationDeg;
      updateUI();
      rerenderGrid();
      if (gpsMarker) highlightCellAt(gpsMarker.getPosition());
    }

    function searchBestRotation(centerDeg, rangeDeg, stepDeg) {
      let bestDeg = centerDeg;
      let bestScore = -Infinity;

      for (let d = centerDeg - rangeDeg; d <= centerDeg + rangeDeg; d += stepDeg) {
        const score = scoreRotation(d);
        if (score > bestScore) {
          bestScore = score;
          bestDeg = d;
        }
      }
      return { bestDeg, bestScore };
    }

    function scoreRotation(rotDeg) {
      const data = prescriptionData;
      const boundaryRing = window.__boundaryRing;
      const theta = degToRad(rotDeg);

      const { rows, columns, cellSize, originLat, originLng, weightData } = data;

      // pivot EN meters relative to origin
      const pivotLat = pivotLatLng.lat();
      const pivotLng = pivotLatLng.lng();
      const pivotNorthM = (pivotLat - originLat) * 111320;
      const pivotEastM  = (pivotLng - originLng) * (111320 * Math.cos(pivotLat * Math.PI / 180));

      let insideCount = 0;

      for (let row = 0; row < rows; row++) {
        for (let col = 0; col < columns; col++) {
          const idx = row * columns + col;
          const level = weightData[idx];
          if (!level || level === 0) continue;

          const drawRow = (rows - 1 - row);
          const drawCol = col;

          const e = drawCol * cellSize + cellSize/2;
          const n = drawRow * cellSize + cellSize/2;

          const eRel = e - pivotEastM;
          const nRel = n - pivotNorthM;

          const rot = rotateEN(eRel, nRel, theta);
          const e2 = rot.east + pivotEastM;
          const n2 = rot.north + pivotNorthM;

          const lat = originLat + metersToLat(n2);
          const lng = originLng + metersToLng(e2, lat);

          if (pointInPolygon({lat, lng}, boundaryRing)) insideCount++;
        }
      }
      return insideCount;
    }

    function fitToBoundary() {
      if (boundaryBounds) map.fitBounds(boundaryBounds);
    }

    function fitToGrid() {
      const bounds = new google.maps.LatLngBounds();
      let any = false;

      map.data.forEach(feature => {
        const geom = feature.getGeometry();
        if (!geom) return;
        geom.forEachLatLng(latlng => {
          bounds.extend(latlng);
          any = true;
        });
      });

      if (any) map.fitBounds(bounds);
      else alert("No grid cells rendered (maybe all clipped).");
    }
  </script>
  <script>
  if ("serviceWorker" in navigator) {
    window.addEventListener("load", () => {
      navigator.serviceWorker.register("/service-worker.js")
        .catch(err => console.warn("SW registration failed:", err));
    });
  }
</script>
</body>
</html>







<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>SwagriTech Vineyard Maps</title>

  <!-- PWA -->
  <link rel="manifest" href="/manifest.webmanifest">
  <meta name="theme-color" content="#ffffff">
  <link rel="apple-touch-icon" sizes="180x180" href="/icons/apple-touch-icon.png">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="default">

  <style>
    body { margin: 0; font-family: Arial, sans-serif; }
    #map { height: 100vh; width: 100%; }

    .controls {
      position: absolute;
      top: 10px; left: 10px;
      background: white;
      padding: 10px;
      border-radius: 10px;
      box-shadow: 0 2px 10px rgba(0,0,0,0.25);
      z-index: 1;
      min-width: 320px;
      user-select: none;
    }

    .row { margin-top: 8px; }
    .btnRow { display: flex; gap: 6px; flex-wrap: wrap; }
    button { flex: 1; padding: 7px 8px; cursor: pointer; }
    select { width: 100%; padding: 6px; }

    .small { font-size: 12px; color: #555; line-height: 1.25; }
    .mono { font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace; }

    .pill {
      display:inline-block;
      padding: 2px 10px;
      border-radius: 999px;
      background: #eee;
      font-size: 12px;
      font-weight: 700;
      color: #111;
    }

    .checkRow { display:flex; gap:10px; flex-wrap:wrap; }
    .checkRow label { font-size: 12px; display:flex; align-items:center; gap:6px; }
    hr { border: none; border-top: 1px solid #eee; margin: 10px 0; }
  </style>

  <script
    src="https://maps.googleapis.com/maps/api/js?key=AIzaSyAmR2Rk1b0drx0zCWI6LMjdkRP2f_Lk-0E&callback=initMap"
    async defer></script>
</head>

<body>
  <div class="controls">
    <strong>SwagriTech Vineyard Maps</strong>

    <div class="row small">
      Customer: <span id="customerLabel" class="mono">—</span><br>
      Block: <span id="blockLabel" class="mono">—</span><br>
      Status: <span id="statusLabel" class="mono">Loading…</span>
    </div>

    <div class="row">
      <label class="small"><strong>Select block</strong></label>
      <select id="blockSelect"></select>
    </div>

    <div class="row">
      <strong>Zone filters</strong>
      <div class="checkRow">
        <label><input type="checkbox" id="z1" checked> Red</label>
        <label><input type="checkbox" id="z2" checked> Orange</label>
        <label><input type="checkbox" id="z3" checked> Green</label>
      </div>
    </div>

    <hr>

    <strong>GPS Walking</strong>
    <div class="btnRow row">
      <button onclick="startGPS()">Start</button>
      <button onclick="stopGPS()">Stop</button>
      <button onclick="toggleFollow()">Follow: <span id="followLabel" class="mono">ON</span></button>
    </div>

    <div class="row small">
      GPS: <span id="gpsLabel" class="mono">OFF</span>
      &nbsp; Acc: <span id="accLabel" class="mono">—</span><br>
      You are in: <span id="zoneLabel" class="pill">—</span>
    </div>
  </div>

  <div id="map"></div>

  <script>
    // ---------------------------
    // Config
    // ---------------------------
    const DEFAULT_CUSTOMER = "Menzies";

    // Throttle GPS processing (ms). Lower = more responsive, higher = less CPU.
    const GPS_PROCESS_THROTTLE_MS = 300;

    // ---------------------------
    // Routing helpers
    // ---------------------------
    function getCustomerIdFromPath() {
      const trimmed = location.pathname.replace(/^\/+|\/+$/g, "");
      if (!trimmed) return DEFAULT_CUSTOMER;
      const first = decodeURIComponent(trimmed.split("/")[0]);
      const reserved = ["customers", "icons", "favicon.ico", "manifest.webmanifest", "service-worker.js"];
      if (reserved.includes(first.toLowerCase())) return DEFAULT_CUSTOMER;
      return first;
    }

    function getQueryParam(name) {
      return new URL(location.href).searchParams.get(name);
    }

    function setQueryParam(name, value) {
      const u = new URL(location.href);
      if (value == null) u.searchParams.delete(name);
      else u.searchParams.set(name, value);
      history.replaceState({}, "", u);
    }

    // ---------------------------
    // Paths
    // ---------------------------
    function blocksIndexUrl(customer) {
      return `/customers/${encodeURIComponent(customer)}/blocks.json`;
    }

    // Your naming format:
    // boundary: block<NUM>boundary.geojson
    // rx:       block<NUM>rx.geojson
    function blockDataPaths(customer, blockId) {
      const c = encodeURIComponent(customer);
      const b = encodeURIComponent(blockId);
      return {
        boundary: `/customers/${c}/blocks/${b}/block${b}boundary.geojson`,
        rx:       `/customers/${c}/blocks/${b}/block${b}rx.geojson`
      };
    }

    // ---------------------------
    // Globals
    // ---------------------------
    let map;
    let boundaryLayer, zonesLayer;

    let customerId = null;
    let blocksConfig = null;
    let currentBlockId = null;

    // GPS
    let gpsWatch = null;
    let gpsMarker = null;
    let gpsCircle = null;
    let followMode = true;

    // Throttle helpers
    let lastGpsProcessAt = 0;

    // Zone hit-testing cache
    // Keep only what we need for fast hit-testing.
    let zoneGeoms = []; // { zone, geo }
    let highlightedZone = null;

    // ---------------------------
    // UI helpers
    // ---------------------------
    const $ = (id) => document.getElementById(id);
    const setStatus = (t) => ($("statusLabel").textContent = t);

    function zoneToColor(z) {
      if (z === 1) return "#ff0000";
      if (z === 2) return "#ffa500";
      if (z === 3) return "#00ff00";
      return "#00bfff";
    }

    function zoneEnabled(z) {
      if (z === 1) return $("z1").checked;
      if (z === 2) return $("z2").checked;
      if (z === 3) return $("z3").checked;
      return true;
    }

    function zoneNameFromNumber(z) {
      if (z === 1) return "Red zone";
      if (z === 2) return "Orange zone";
      if (z === 3) return "Green zone";
      return `Zone ${z}`;
    }

    // NEW: colour the "You are in" pill
    function setZonePill(zoneNum) {
      const pill = $("zoneLabel");

      if (zoneNum === 1) {
        pill.textContent = "Red zone";
        pill.style.background = "#ff0000";
        pill.style.color = "#ffffff";
      } else if (zoneNum === 2) {
        pill.textContent = "Orange zone";
        pill.style.background = "#ffa500";
        pill.style.color = "#111111";
      } else if (zoneNum === 3) {
        pill.textContent = "Green zone";
        pill.style.background = "#00ff00";
        pill.style.color = "#111111";
      } else if (zoneNum == null) {
        pill.textContent = "Outside zones";
        pill.style.background = "#eee";
        pill.style.color = "#111";
      } else {
        pill.textContent = zoneNameFromNumber(zoneNum);
        pill.style.background = "#eee";
        pill.style.color = "#111";
      }
    }

    // ---------------------------
    // GeoJSON loading (awaitable)
    // ---------------------------
    function loadGeoJsonIntoLayer(layer, url) {
      return new Promise((resolve, reject) => {
        fetch(url, { cache: "no-store" })
          .then(r => {
            if (!r.ok) throw new Error(`HTTP ${r.status} for ${url}`);
            return r.json(); // validate JSON
          })
          .then(() => {
            layer.loadGeoJson(url, null, () => resolve());
          })
          .catch(reject);
      });
    }

    function computeLayerBounds(layer) {
      const b = new google.maps.LatLngBounds();
      let any = false;
      layer.forEach(f => {
        const g = f.getGeometry();
        if (!g) return;
        g.forEachLatLng(ll => { b.extend(ll); any = true; });
      });
      return any ? b : null;
    }

    function geometryToGeoJson(g) {
      if (!g) return null;
      const t = g.getType();

      if (t === "Polygon") {
        return {
          type: "Polygon",
          coordinates: g.getArray().map(ring =>
            ring.getArray().map(p => [p.lng(), p.lat()])
          )
        };
      }

      if (t === "MultiPolygon") {
        return {
          type: "MultiPolygon",
          coordinates: g.getArray().map(poly =>
            poly.getArray().map(ring =>
              ring.getArray().map(p => [p.lng(), p.lat()])
            )
          )
        };
      }

      return null;
    }

    // ---------------------------
    // Point in polygon
    // ---------------------------
    function pointInRing(x, y, ring) {
      let inside = false;
      for (let i = 0, j = ring.length - 1; i < ring.length; j = i++) {
        const xi = ring[i][0], yi = ring[i][1];
        const xj = ring[j][0], yj = ring[j][1];
        const intersect =
          ((yi > y) !== (yj > y)) &&
          (x < (xj - xi) * (y - yi) / ((yj - yi) || 1e-12) + xi);
        if (intersect) inside = !inside;
      }
      return inside;
    }

    function pointInPolygon(x, y, rings) {
      if (!rings || rings.length === 0) return false;
      if (!pointInRing(x, y, rings[0])) return false;
      for (let h = 1; h < rings.length; h++) {
        if (pointInRing(x, y, rings[h])) return false;
      }
      return true;
    }

    function pointInGeom(x, y, geom) {
      if (!geom) return false;
      if (geom.type === "Polygon") return pointInPolygon(x, y, geom.coordinates);
      if (geom.type === "MultiPolygon") return geom.coordinates.some(p => pointInPolygon(x, y, p));
      return false;
    }

    // ---------------------------
    // Styling
    // ---------------------------
    function styleZones(feature) {
      const z = Number(feature.getProperty("zone"));
      const enabled = zoneEnabled(z);
      const isHighlighted = (highlightedZone != null && z === highlightedZone);

      return {
        visible: enabled,
        fillColor: zoneToColor(z),
        fillOpacity: isHighlighted ? 0.75 : 0.55,
        strokeColor: isHighlighted ? "#1a73e8" : "#000000",
        strokeOpacity: isHighlighted ? 1.0 : 0.6,
        strokeWeight: isHighlighted ? 2.5 : 0.6
      };
    }

    function refreshZones() {
      zonesLayer.setStyle(styleZones);
    }

    // ---------------------------
    // Init
    // ---------------------------
    async function initMap() {
      customerId = getCustomerIdFromPath();
      $("customerLabel").textContent = customerId;

      $("followLabel").textContent = "ON";
      $("gpsLabel").textContent = "OFF";
      $("accLabel").textContent = "—";
      setZonePill(undefined);

      map = new google.maps.Map($("map"), {
        mapTypeId: "satellite",
        center: { lat: -33.8, lng: 115.08 },
        zoom: 17
      });

      boundaryLayer = new google.maps.Data({ map });
      zonesLayer = new google.maps.Data({ map });

      boundaryLayer.setStyle({
        strokeColor: "#00ffff",
        strokeWeight: 2,
        fillColor: "#00ffff",
        fillOpacity: 0.06
      });

      zonesLayer.setStyle(styleZones);

      // Filters: restyle, then re-check current GPS position (but avoid full restyle loops)
      ["z1","z2","z3"].forEach(id => $(id).addEventListener("change", () => {
        refreshZones();
        if (gpsMarker) highlightZoneAt(gpsMarker.getPosition(), { forceUpdate: true });
      }));

      // Load blocks list
      setStatus("Loading blocks…");
      try {
        blocksConfig = await fetchJson(blocksIndexUrl(customerId));
      } catch (e) {
        console.error(e);
        setStatus("ERROR");
        alert(`Could not load blocks.json.\n\nExpected:\n${blocksIndexUrl(customerId)}\n\nCheck that file exists and is valid JSON.`);
        return;
      }

      populateBlocksDropdown(blocksConfig);

      const qBlock = getQueryParam("block");
      const defaultBlock = blocksConfig.defaultBlock || (blocksConfig.blocks?.[0]?.id);
      const initial = (qBlock && hasBlock(qBlock)) ? qBlock : defaultBlock;

      if (!initial) {
        setStatus("ERROR");
        alert("blocks.json contains no blocks.");
        return;
      }

      await loadBlock(initial);
    }

    async function fetchJson(url) {
      const r = await fetch(url, { cache: "no-store" });
      if (!r.ok) throw new Error(`HTTP ${r.status} for ${url}`);
      return r.json();
    }

    function hasBlock(id) {
      return (blocksConfig?.blocks || []).some(b => String(b.id) === String(id));
    }

    function populateBlocksDropdown(cfg) {
      const sel = $("blockSelect");
      sel.innerHTML = "";

      for (const b of (cfg.blocks || [])) {
        const opt = document.createElement("option");
        opt.value = String(b.id);
        opt.textContent = b.name ? b.name : `Block ${b.id}`;
        sel.appendChild(opt);
      }

      sel.addEventListener("change", async () => {
        await loadBlock(sel.value);
      });
    }

    // ---------------------------
    // Block loading
    // ---------------------------
    async function loadBlock(blockId) {
      currentBlockId = String(blockId);
      $("blockLabel").textContent = currentBlockId;
      setQueryParam("block", currentBlockId);

      const sel = $("blockSelect");
      if (sel.value !== currentBlockId) sel.value = currentBlockId;

      // Clear old features/caches
      boundaryLayer.forEach(f => boundaryLayer.remove(f));
      zonesLayer.forEach(f => zonesLayer.remove(f));
      zoneGeoms = [];
      highlightedZone = null;
      setZonePill(undefined);

      const paths = blockDataPaths(customerId, currentBlockId);
      setStatus("Loading block data…");

      try {
        await loadGeoJsonIntoLayer(boundaryLayer, paths.boundary);
        await loadGeoJsonIntoLayer(zonesLayer, paths.rx);

        const b1 = computeLayerBounds(boundaryLayer);
        const b2 = computeLayerBounds(zonesLayer);
        const bounds = b1 || b2;
        if (bounds) map.fitBounds(bounds);

        // Build hit-test cache (zone number + geometry)
        zonesLayer.forEach(f => {
          const z = Number(f.getProperty("zone"));
          const geo = geometryToGeoJson(f.getGeometry());
          zoneGeoms.push({ zone: z, geo });
        });

        refreshZones();
        if (gpsMarker) highlightZoneAt(gpsMarker.getPosition(), { forceUpdate: true });

        setStatus("OK");
      } catch (e) {
        console.error(e);
        setStatus("ERROR");
        alert(
          `Failed to load block ${currentBlockId}.\n\n` +
          `Expected:\n${paths.boundary}\n${paths.rx}\n\n` +
          `Check the file paths exist and are valid GeoJSON.`
        );
      }
    }

    // ---------------------------
    // GPS
    // ---------------------------
    function toggleFollow() {
      followMode = !followMode;
      $("followLabel").textContent = followMode ? "ON" : "OFF";
    }

    function startGPS() {
      if (!navigator.geolocation) {
        alert("Geolocation not supported.");
        return;
      }
      if (gpsWatch) return;

      $("gpsLabel").textContent = "ON";

      gpsWatch = navigator.geolocation.watchPosition(
        (pos) => {
          const now = Date.now();
          if (now - lastGpsProcessAt < GPS_PROCESS_THROTTLE_MS) return;
          lastGpsProcessAt = now;

          const ll = new google.maps.LatLng(pos.coords.latitude, pos.coords.longitude);
          $("accLabel").textContent = `${Math.round(pos.coords.accuracy)}m`;

          // Blue dot marker
          if (!gpsMarker) {
            gpsMarker = new google.maps.Marker({
              map,
              position: ll,
              title: "You",
              icon: {
                path: google.maps.SymbolPath.CIRCLE,
                scale: 8,
                fillColor: "#1a73e8",
                fillOpacity: 1,
                strokeColor: "#ffffff",
                strokeOpacity: 1,
                strokeWeight: 3
              },
              zIndex: 9999
            });
          } else {
            gpsMarker.setPosition(ll);
          }

          // Accuracy circle (blue)
          if (!gpsCircle) {
            gpsCircle = new google.maps.Circle({
              map,
              center: ll,
              radius: pos.coords.accuracy,
              strokeColor: "#1a73e8",
              strokeOpacity: 0.35,
              strokeWeight: 1,
              fillColor: "#1a73e8",
              fillOpacity: 0.12
            });
          } else {
            gpsCircle.setCenter(ll);
            gpsCircle.setRadius(pos.coords.accuracy);
          }

          if (followMode) map.panTo(ll);
          highlightZoneAt(ll);
        },
        (err) => {
          console.error(err);
          $("gpsLabel").textContent = "ERROR";
          alert("GPS Error: " + err.message);
        },
        { enableHighAccuracy: true, maximumAge: 1000, timeout: 15000 }
      );
    }

    function stopGPS() {
      if (gpsWatch) navigator.geolocation.clearWatch(gpsWatch);
      gpsWatch = null;

      $("gpsLabel").textContent = "OFF";
      $("accLabel").textContent = "—";

      highlightedZone = null;
      setZonePill(undefined);
      refreshZones();

      if (gpsMarker) { gpsMarker.setMap(null); gpsMarker = null; }
      if (gpsCircle) { gpsCircle.setMap(null); gpsCircle = null; }
    }

    // KEY PERFORMANCE FIX:
    // - Only call zonesLayer.setStyle() when the zone actually changes (or forced).
    function highlightZoneAt(latLng, { forceUpdate = false } = {}) {
      const x = latLng.lng();
      const y = latLng.lat();

      let foundZone = null;
      for (const z of zoneGeoms) {
        if (!zoneEnabled(z.zone)) continue;
        if (pointInGeom(x, y, z.geo)) { foundZone = z.zone; break; }
      }

      const newZone = (foundZone != null) ? foundZone : null;

      if (!forceUpdate && newZone === highlightedZone) {
        // No change → do NOT restyle all polygons again.
        return;
      }

      highlightedZone = newZone;

      // Update pill colour/text
      if (highlightedZone == null) setZonePill(null);
      else setZonePill(highlightedZone);

      // Restyle polygons ONLY when zone changes (or forced)
      refreshZones();
    }
  </script>
</body>
</html>
